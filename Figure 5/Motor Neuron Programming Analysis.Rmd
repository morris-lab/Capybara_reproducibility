---
title: "Motor Neuron Programming Analysis"
output: html_notebook
---

### Brief Description
In this notebook, we document the analysis of motor neuron programming, charting the time course progression during this programming process. We use this dataset to showcase application of Capybara to demonstrate the utility of transition scores (Briggs et al, 2017) as well as refinement of the protocol with additional small molecules. In this notebook file, we will focus on the transition scores as well as new analysis for the sample with signaling molecules. Hence, we start with previous outcomes from Capybara. The Briggs et al. datasets were processed through standard Seurat V4 pipeline and the detailed classifications are included in the Seurat objects. 

For details of the Briggs dataset, please refer to the Briggs paper here (https://elifesciences.org/articles/26945). For details of Capybara, please refer to the Capybara paper here (https://www.sciencedirect.com/science/article/pii/S1934590922000996?dgcid=coauthor).

### Load packages
```{r}
library(Seurat)
library(Capybara)
library(ggplot2)
```

### Briggs et al., 2017 Data
For source data, please refer to the Briggs paper here (https://elifesciences.org/articles/26945). Here, we will focus on the demonstration of transition score calculations and detailed breakdown of the hybrid cells across different time points. In general, we will start with the processed Seurat objects, including the detailed classification outcomes, and identified hybrid populations involved.

#### Load the seurat object
```{r}
dd.obj <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Briggs et al Seurat Objects/seurat_obj_sp_with_classification.Rds")
dp.obj <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Briggs et al Seurat Objects/seurat_obj_dp_with_classification.Rds")
```

#### Multiple labels
Here we look at the different meta data of the data on the UMAP.

1) Separation of Clusters (DD)
```{r, fig.width=5, fig.height=5}
DimPlot(dd.obj, label = TRUE, label.size = 12) + scale_color_brewer(palette = "Paired") + NoLegend()
```

2) Separation of Clusters (DP)
```{r, fig.width=5, fig.height=5}
DimPlot(dp.obj, label = TRUE, label.size = 12) + scale_color_brewer(palette = "Paired") + NoLegend()
```

3) Separation of timepoints (DD)
```{r, fig.width=5, fig.height=5}
DimPlot(dd.obj, label = TRUE, group.by = "tp", label.size = 12) + scale_color_brewer(palette = "Paired") + NoLegend()
```

4) Separation of timepoints (DP)
```{r, fig.width=5, fig.height=5}
DimPlot(dp.obj, label = TRUE, group.by = "tp", label.size = 12) + scale_color_brewer(palette = "Paired") + NoLegend()
```

#### General Calls and Timepoints
1) Here we will group the classification outcomes with the same general cell type, without the specific marker subtypes, specifically to group different kind of ESCs. Note, here we rename multi-ID cells as Hybrids
```{r}
dp.obj@meta.data$more.general.call <- unlist(lapply(strsplit(dp.obj@meta.data$call, "_"), function(x) x[2]))
dp.obj@meta.data[which(startsWith(dp.obj@meta.data$call, "ES_")), "more.general.call"] <- "ESC"
dp.obj@meta.data[which(startsWith(dp.obj@meta.data$call, "Multi_")), "more.general.call"] <- "Hybrid"

dd.obj@meta.data$more.general.call <- unlist(lapply(strsplit(dd.obj@meta.data$call, "_"), function(x) x[2]))
dd.obj@meta.data[which(startsWith(dd.obj@meta.data$call, "ES_")), "more.general.call"] <- "ESC"
dd.obj@meta.data[which(startsWith(dd.obj@meta.data$call, "Multi_")), "more.general.call"] <- "Hybrid"
```

2) Here we further break down the classification to their embryonic time points and their cell type calls.
```{r}
dd.obj@meta.data$mapped_emb <- unlist(lapply(strsplit(dd.obj@meta.data$call, "_"), function(x) x[1]))
dp.obj@meta.data$mapped_emb <- unlist(lapply(strsplit(dp.obj@meta.data$call, "_"), function(x) x[1]))
dd.obj@meta.data$mapped_emb[which(dd.obj@meta.data$mapped_emb == "Multi")] <- NA
dp.obj@meta.data$mapped_emb[which(dp.obj@meta.data$mapped_emb == "Multi")] <- NA

emb.tp.sp <- as.data.frame(table(dd.obj@meta.data$mapped_emb))
rownames(emb.tp.sp) <- as.character(emb.tp.sp$Var1)
colnames(emb.tp.sp) <- c("sp.tp", "DD")
emb.tp.dp <- as.data.frame(table(dp.obj@meta.data$mapped_emb))
rownames(emb.tp.dp) <- as.character(emb.tp.dp$Var1)
colnames(emb.tp.dp) <- c("dp.tp", "DP")

emb.tp.comb <- cbind(emb.tp.sp, emb.tp.dp[rownames(emb.tp.sp), ])
emb.tp.comb.sub <- emb.tp.comb[,c(2,4)]
rownames(emb.tp.comb.sub) <- paste0("E", rownames(emb.tp.comb.sub))
emb.tp.comb.sub.sub <- emb.tp.comb.sub[which(rownames(emb.tp.comb.sub) != "EES"),]

emb.tp.comb.sub.sub <- as.data.frame(apply(emb.tp.comb.sub.sub, 2, function(x) x*100/sum(x)))


emb.tp.comb.sub.sub$stage <- rownames(emb.tp.comb.sub.sub)
emb.tp.comb.sub.melt <- reshape2::melt(emb.tp.comb.sub.sub)

emb.tp.comb.sub.melt$stage <- factor(emb.tp.comb.sub.melt$stage,
                                     levels = rev(c("E9.5", "E10.5", "E11.5", "E12.5", "E13.5")),
                                     ordered = T)
```

3) We look at the mapping to different embryonic stages.
```{r, fig.width=5, fig.height=7}
ggplot(emb.tp.comb.sub.melt, aes(x = variable, y = value, fill = stage)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  theme(legend.position = "right",
        axis.text.x = element_text(face = "bold", size = 12),
        axis.text.y = element_text(face = "bold", size = 12),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold.italic", size = 14),
        panel.grid.major = element_blank(), 
        #        panel.grid.minor = element_line(color = "lightgrey", size = 0.5), 
        panel.background = element_blank(), 
        title = element_text(face = "bold.italic", size = 14),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_blank())
```

4) We look at the major populations for each condition.
I) Direct Differentiation
```{r}
dd.subset <- subset(dd.obj, cells = rownames(dd.obj@meta.data[which(!is.na(dd.obj@meta.data$more.general.call) & 
                                                                      dd.obj@meta.data$more.general.call %in% 
                                                              c("dl3", "dl4", "dp3", "dp4", "ESC", "Mesoderm", "MN", 
                                                                "p2", "pMN","V2a","V3")), ]))
DimPlot(dd.subset, group.by = "more.general.call") + scale_color_brewer(palette = "Paired")
```

II) Direct Programming
```{r}
dp.subset <- subset(dp.obj, cells = rownames(dp.obj@meta.data[which(!is.na(dp.obj@meta.data$more.general.call) &
                                                                      dp.obj@meta.data$more.general.call %in% 
                                                              c("dl3", "dl4", "dl6", "dp3", "dp4", "ESC", "MN", "p2", "V0","V2a","V3")), ]))
DimPlot(dp.subset, group.by = "more.general.call") + scale_color_brewer(palette = "Paired")
```
#### Discrete Cells
1) We group the cells into more generic groups, such as dorsal/ventral progenitors, etc.
```{r}
dorsal.prog <- c("dp1", "dp2", "dp3", "dp4", "dp5", "dp6")
dorsal.neuron <- c("dl1", "dl2", "dl3", "dl4", "dl5", "dl6")
ventral.prog <- c("p0", "p1", "p2", "p3")
ventral.neuron <- c("V0", "V1", "V2a", "V2b", "V3")

dd.obj@meta.data$general <- dd.obj@meta.data$more.general.call
dd.obj@meta.data$general[which(dd.obj@meta.data$general %in% dorsal.prog)] <- "Dorsal.Prog"
dd.obj@meta.data$general[which(dd.obj@meta.data$general %in% dorsal.neuron)] <- "Dorsal.Neuron"
dd.obj@meta.data$general[which(dd.obj@meta.data$general %in% ventral.prog)] <- "Ventral.Prog"
dd.obj@meta.data$general[which(dd.obj@meta.data$general %in% ventral.neuron)] <- "Ventral.Neuron"

dp.obj@meta.data$general <- dp.obj@meta.data$more.general.call
dp.obj@meta.data$general[which(dp.obj@meta.data$general %in% dorsal.prog)] <- "Dorsal.Prog"
dp.obj@meta.data$general[which(dp.obj@meta.data$general %in% dorsal.neuron)] <- "Dorsal.Neuron"
dp.obj@meta.data$general[which(dp.obj@meta.data$general %in% ventral.prog)] <- "Ventral.Prog"
dp.obj@meta.data$general[which(dp.obj@meta.data$general %in% ventral.neuron)] <- "Ventral.Neuron"
```

2) We will plot the composition of major cell types (cell types represented by more than 10 cells at each time point)
I) Direct Differentiation (1 = Day 0, 2 = Day 5, 3 = Day 12)
```{r}
dd.obj.usable.ct <- names(which(table(dd.obj@meta.data$general) > 10))
dd.obj.meta <- dd.obj@meta.data[which(dd.obj@meta.data$general %in% dd.obj.usable.ct & (dd.obj@meta.data$general != "Hybrid")), ]
dd.obj.meta.table.raw <- table(dd.obj.meta$general, dd.obj.meta$tp)
dd.obj.meta.table.raw[which(dd.obj.meta.table.raw < 10)] <- 0
dd.obj.meta.table <- as.data.frame(apply(dd.obj.meta.table.raw, 2, function(x) x*100/sum(x)))
dd.obj.meta.table$ct <- rownames(dd.obj.meta.table)
dd.obj.meta.table.melt <- reshape2::melt(dd.obj.meta.table)

dd.obj.meta.table.melt$ct <- factor(dd.obj.meta.table.melt$ct,
                                    levels = c("ESC", "Mesoderm", "RP", "Dorsal.Prog",
                                               "Ventral.Prog", "pMN", "Dorsal.Neuron", "Ventral.Neuron", "MN"),
                                    ordered = T)

ggplot(dd.obj.meta.table.melt, aes(x = ct, y = variable, size = ifelse(value == 0, NA, value), color = variable)) +
  geom_point() +
  scale_color_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  scale_size_area(max_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

II) Direct Differentiation (1 = Day -1, 2 = Day 4, 3 = Day 11)
```{r}
dp.obj.usable.ct <- names(which(table(dp.obj@meta.data$general) > 10))
dp.obj.meta <- dp.obj@meta.data[which(dp.obj@meta.data$general %in% dp.obj.usable.ct & (dp.obj@meta.data$general != "Hybrid")), ]
dp.obj.meta.table.raw <- table(dp.obj.meta$general, dp.obj.meta$tp)
dp.obj.meta.table.raw[which(dp.obj.meta.table.raw < 10)] <- 0
dp.obj.meta.table <- as.data.frame(apply(dp.obj.meta.table.raw, 2, function(x) x*100/sum(x)))
dp.obj.meta.table$ct <- rownames(dp.obj.meta.table)
dp.obj.meta.table.melt <- reshape2::melt(dp.obj.meta.table)

dp.obj.meta.table.melt$ct <- factor(dp.obj.meta.table.melt$ct,
                                    levels = c("ESC", "Mesoderm", "RP", "Dorsal.Prog",
                                               "Ventral.Prog", "pMN", "Dorsal.Neuron", "Ventral.Neuron", "MN"),
                                    ordered = T)

ggplot(dp.obj.meta.table.melt, aes(x = ct, y = variable, size = ifelse(value == 0, NA, value), color = variable)) +
  geom_point() +
  scale_color_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  scale_size_area(max_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
Looking at the discrete cell types, we observe a diverse range of motor neurons arising from the programming and differentiation of MNs from ESCs, suggesting a potential dorsal-ventral patterning deficiency in this protocol.

#### Hybrid cells
Here we will look at the different hybrid breakdowns across the different timepoints in the programming/ differentiation timecourse.

1) Direct Differentiation - we first load the filtered hybrid cells in this time course and break them down by percentage represented across timepoints, including day 0, day 5, and day 12. In the direct differentiation, we added the hybrid information on day 0 separately as we processed the ESC cells separately.
```{r}
## Load the multi files. This multi-file is generated from the multi.id.curate.qp function, slot 1.
actual.multi <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Briggs et al Filtered Multi-ID/DD_filtered_multi.Rds")
bin.count.esc.sp <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Briggs et al Filtered Multi-ID/DD_ESC_bin_counts.Rds")

multi.id.cells.sp <- unique(actual.multi$cell.bc)
sp.df <- data.frame()
for (mic in multi.id.cells.sp) {
  curr.ct <- as.character(actual.multi[which(actual.multi$cell.bc == mic), "variable"])
  curr.ct <- gsub("frxn_cell.type_", "", curr.ct)
  
  curr.ct <- unlist(lapply(strsplit(curr.ct, "_"), function(x) x[[2]]))
  curr.df <- data.frame(cell.id = mic, cell.type = paste0(sort(unique(curr.ct)), collapse = "-"))
  
  if (nrow(sp.df) <= 0) {
    sp.df <- curr.df
  } else {
    sp.df <- rbind(sp.df, curr.df)
  }
}

d0.sp <- rownames(dd.obj@meta.data)[which(dd.obj@meta.data$more.general.call == "Hybrid")]
bin.count.sub <- bin.count.esc.sp[intersect(d0.sp, rownames(bin.count.esc.sp)), ]

esc.sp.df <- data.frame()
for (mic in rownames(bin.count.sub)) {
  curr.ct <- as.character(names(which(bin.count.sub[mic, ] == 1)))
  curr.ct <- gsub("frxn_cell.type_", "", curr.ct)
  if (length(curr.ct) == 2) {
    curr.ct <- unlist(lapply(strsplit(curr.ct, "_"), function(x) x[[2]]))
    curr.df <- data.frame(cell.id = mic, cell.type = paste0(sort(unique(curr.ct)), collapse = "-"))
    
    if (nrow(sp.df) <= 0) {
      esc.sp.df <- curr.df
    } else {
      esc.sp.df <- rbind(esc.sp.df, curr.df)
    }
  }
}
```

Clean up the data based on thresholds for significant hybrid identities and plot across timepoints
```{r}
sp.df.tp.table <- dd.obj@meta.data
rownames(sp.df.tp.table) <- unlist(lapply(strsplit(rownames(sp.df.tp.table), "-"), function(x) paste0(x[1], "-")))

sp.df$tp <- sp.df.tp.table[sp.df$cell.id, "tp"]
esc.sp.df$tp <- 1
comb.sp <- rbind(sp.df, esc.sp.df)
sp.df.table <- as.data.frame(apply(table(comb.sp$cell.type, comb.sp$tp), 2, function(x) x))
colnames(sp.df.table) <- c("Day 0", "Day 5", "Day 12")
sp.df.table$`Day 0`[which(sp.df.table$`Day 0` < 4.605)] <- 0
sp.df.table$`Day 5`[which(sp.df.table$`Day 5` < 4.985)] <- 0
sp.df.table$`Day 12`[which(sp.df.table$`Day 12` < 5.285)] <- 0
sp.df.table.zeros <- apply(sp.df.table, 1, function(x) all(x == 0))
sp.df.table.sub <- sp.df.table[which(!sp.df.table.zeros), ]
sp.df.table.sub <- as.data.frame(apply(sp.df.table.sub, 2, function(x) x*100/sum(x)))
sp.df.table.sub$cell.type <- rownames(sp.df.table.sub)

sp.df.table.sub.sort <- sp.df.table.sub[order(sp.df.table.sub$`Day 12`, sp.df.table.sub$`Day 5`), ]

sp.df.table.sub.melt <- reshape2::melt(sp.df.table.sub)
sp.df.table.sub.melt$cell.type <- factor(sp.df.table.sub.melt$cell.type,
                                         levels = sp.df.table.sub.sort$cell.type,
                                         ordered = T)

ggplot(sp.df.table.sub.melt, aes(x = cell.type, y = value, fill = cell.type)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(variable~.) +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  labs(y = "Percentage Composition") +
  theme(legend.position = "none",
        axis.text.x = element_text(face = "bold", angle = 90, size = 12),
        axis.text.y = element_text(face = "bold", size = 12),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold.italic", size = 14),
        panel.grid.major = element_line(color = "lightgrey", size = 0.5), 
        panel.grid.minor = element_line(color = "lightgrey", size = 0.5), 
        panel.background = element_rect(color = "black", fill = "white"), 
        title = element_text(face = "bold.italic", size = 14),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_blank())
```

2) Direct Programming - we first load the filtered hybrid cells in this time course and break them down to percentage represented across timepoints, including day -1, day 4, and day 11. 
```{r}
## Load the multi files. This multi-file is generated from the multi.id.curate.qp function, slot 1.
actual.multi.dp <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Briggs et al Filtered Multi-ID/DP_filtered_multi.Rds")
multi.id.cells <- unique(actual.multi.dp$cell.bc)

dp.df <- data.frame()
for (mic in multi.id.cells) {
  curr.ct <- as.character(actual.multi.dp[which(actual.multi.dp$cell.bc == mic), "variable"])
  curr.ct <- gsub("frxn_cell.type_", "", curr.ct)
  if (length(which(startsWith(curr.ct, "ES"))) > 0) curr.ct[which(startsWith(curr.ct, "ES"))] <- "ES_ES"
  
  curr.ct <- unlist(lapply(strsplit(curr.ct, "_"), function(x) x[[2]]))
  curr.df <- data.frame(cell.id = mic, cell.type = paste0(sort(unique(curr.ct)), collapse = "-"))
  
  if (nrow(dp.df) <= 0) {
    dp.df <- curr.df
  } else {
    dp.df <- rbind(dp.df, curr.df)
  }
}
```

Clean up the data based on thresholds for significant hybrid identities and plot across timepoints
```{r}
dp.df$tp <- unlist(lapply(strsplit(dp.df$cell.id, "-"), function(x) x[2]))
dp.df.table <- as.data.frame(apply(table(dp.df$cell.type, dp.df$tp), 2, function(x) x))
colnames(dp.df.table) <- c("Day -1", "Day 4", "Day 11")
dp.df.table$`Day -1`[which(dp.df.table$`Day -1` < 4.605)] <- 0
dp.df.table$`Day 4`[which(dp.df.table$`Day 4` < 3.51)] <- 0
dp.df.table$`Day 11`[which(dp.df.table$`Day 11` < 4.99)] <- 0
dp.df.table.zeros <- apply(dp.df.table, 1, function(x) all(x == 0))
dp.df.table.sub <- dp.df.table[which(!dp.df.table.zeros), ]
dp.df.table.sub <- as.data.frame(apply(dp.df.table.sub, 2, function(x) x*100/sum(x)))
dp.df.table.sub$cell.type <- rownames(dp.df.table.sub)

dp.df.table.sub.melt <- reshape2::melt(dp.df.table.sub)

ggplot(dp.df.table.sub.melt, aes(x = cell.type, y = value, fill = cell.type)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(variable~.) +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  labs(y = "Percentage Composition") +
  theme(legend.position = "none",
        axis.text.x = element_text(face = "bold", size = 12),
        axis.text.y = element_text(face = "bold", size = 12),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold.italic", size = 14),
        panel.grid.major = element_line(color = "lightgrey", size = 0.5), 
        panel.grid.minor = element_line(color = "lightgrey", size = 0.5), 
        panel.background = element_rect(color = "black", fill = "white"), 
        title = element_text(face = "bold.italic", size = 14),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_blank())
```

#### Transition Scores
1) Calculate the transition scores
```{r}
dd.scores.df <- transition.score(actual.multi)
dp.scores.df <- transition.score(actual.multi.dp)

dd.obj@meta.data$transition.scores <- dd.scores.df[dd.obj@meta.data$call, "entropy"]
dp.obj@meta.data$transition.scores <- dp.scores.df[dp.obj@meta.data$call, "entropy"]
```

2) Violin plots to compare transition scores across the time points
I) Direct Programming
```{r, warning=FALSE}
## Ref: https://stackoverflow.com/questions/17319487/median-and-quartile-on-violin-plots-in-ggplot2
median.quartile <- function(x){
  out <- quantile(x, probs = c(0.25,0.5,0.75))
  names(out) <- c("ymin","y","ymax")
  return(out) 
}

ggplot(dp.obj@meta.data[-which(is.na(dp.obj@meta.data$transition.score)),], aes(x = tp, y = transition.scores, fill = tp, color = tp)) +
  geom_violin(scale = "width") +
  stat_summary(fun.y=median.quartile,geom='point', color = rep(rev(viridis(20, option = "A")[c(1,5,10)]), each = 3)) +
  stat_summary(fun.y=median.quartile,geom='line', color = rep(rev(viridis(20, option = "A")[c(1,5,10)]), each = 3)) +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  scale_color_viridis_d(option = "A", begin = 0.15, end = 0.85)

```

II) Direct Differentiation
```{r}
ggplot(dd.obj@meta.data[-which(is.na(dd.obj@meta.data$transition.score)),], aes(x = tp, y = transition.scores, fill = tp, color = tp)) +
  geom_violin(scale = "width") +
  stat_summary(fun.y=median.quartile,geom='point', color = rep(rev(viridis(20, option = "A")[c(1,5,10)]), each = 3)) +
  stat_summary(fun.y=median.quartile,geom='line', color = rep(rev(viridis(20, option = "A")[c(1,5,10)]), each = 3)) +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  scale_color_viridis_d(option = "A", begin = 0.15, end = 0.85)
```

Overall, we identified a potential dorsal-ventral deficiency in this system and found significant decrease in transition scores from first time point to the second in both DD and DP. In DD, there is no significant change in transition score from day 5 to day 12. Yet, in DP, there is a significant decrease in transition scores from day 4 to day 11, suggesting potential more driven protocol of direct programming. Next, we explore the effect of signaling modulation of this programming protocol, including RA and SAG.

### NOTE: We will clean up the data from the first part before starting the second section
```{r}
rm(list = ls())
gc()
```

### Direct Motor Neuron Programming with RA and SAG
For source data, please refer to the GEO source data. The reference data is offered under the folder 'Reference Data'. As this dataset contains a total of 8 samples processed separately. If interested, please follow along the pipeline offered in the other notebooks to run through the pipeline for the samples. Here, we will focus on the comparison of the outcomes from treatment of different signaling molecules, such as RA and SAG, and showcase the improvement from such interventions. In general, we will start with the processed Seurat objects, binarization counts, classification outcomes, and quadratic programming scores.

#### Seurat Object with Classifications
1) First, we load the preprocessed seurat object, the binarization counts, and classification outcomes. As aforementioned, Capybara classification was executed separately on these datasets. Thus, we combine the classification results.
```{r}
mn.integrated <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Seurat Object/mn_10x_indrop_integrated_final.Rds")

rep2.bin.class <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Binarization and Classification Outcomes/012521_MN_binarization_classification_Rep2.Rds")
rep1.bin.class <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Binarization and Classification Outcomes/113020_MN_binarization_classification.Rds")

rep2.classification.all <- data.frame()
rep1.classification.all <- data.frame()

for (i in 1:length(rep1.bin.class)) {
  curr.class.rep.1 <- rep1.bin.class[[i]][[2]]
  curr.class.rep.2 <- rep2.bin.class[[i]][[2]]
  curr.class.name <- names(rep1.bin.class)[[i]]
  if (curr.class.name == "dox") {
    rownames(curr.class.rep.1) <- paste0("mn.dox_R1_", rownames(curr.class.rep.1))
    rownames(curr.class.rep.2) <- paste0("mn.dox_R2_", rownames(curr.class.rep.2))
  } else if (curr.class.name == "dox_ra_sag") {
    rownames(curr.class.rep.1) <- paste0("mn.dox.ra.sag_R1_", rownames(curr.class.rep.1))
    rownames(curr.class.rep.2) <- paste0("mn.dox.ra.sag_R2_", rownames(curr.class.rep.2))
  } else if (curr.class.name == "dox_ra") {
    rownames(curr.class.rep.1) <- paste0("mn.dox.ra_R1_", rownames(curr.class.rep.1))
    rownames(curr.class.rep.2) <- paste0("mn.dox.ra_R2_", rownames(curr.class.rep.2))
  } else if (curr.class.name == "dox_sag") {
    rownames(curr.class.rep.1) <- paste0("mn.dox.sag_R1_", rownames(curr.class.rep.1))
    rownames(curr.class.rep.2) <- paste0("mn.dox.sag_R2_", rownames(curr.class.rep.2))
  } else if (curr.class.name == "ra_sag") {
    rownames(curr.class.rep.1) <- paste0("mn.ra.sag_R1_", rownames(curr.class.rep.1))
    rownames(curr.class.rep.2) <- paste0("mn.ra.sag_R2_", rownames(curr.class.rep.2))
  } else {
    rownames(curr.class.rep.1) <- paste0("mn.no.dox_R1_", rownames(curr.class.rep.1))
    rownames(curr.class.rep.2) <- paste0("mn.no.dox_R2_", rownames(curr.class.rep.2))
  }
  
  if (nrow(rep2.classification.all) <= 0) {
    rep2.classification.all <- curr.class.rep.2
    rep1.classification.all <- curr.class.rep.1
  } else {
    rep2.classification.all <- rbind(rep2.classification.all, curr.class.rep.2)
    rep1.classification.all <- rbind(rep1.classification.all, curr.class.rep.1)
  }
}
```

2) Here we add the classification results to the Seurat object and label each cluster according to their major cell type.
```{r}
rep1.cells <- intersect(rownames(mn.integrated@meta.data), rownames(rep1.classification.all))
rep2.cells <- intersect(rownames(mn.integrated@meta.data), rownames(rep2.classification.all))

mn.integrated@meta.data[rep1.cells, "capy.call"] <- rep1.classification.all[rep1.cells, "call"]
mn.integrated@meta.data[rep2.cells, "capy.call"] <- rep2.classification.all[rep2.cells, "call"]

new.cluster.ids <- c("ESC", "MN/ES", "MN", "MN", "ESC", "ESC", "ESC", "MN/ES", "ESC", "ESC/Eryth", "V2a/ESC", 
                     "ESC/pMN/MN", "V2a/MN/ESC", "MN", "V2a/dl3", "Eryth/ESC/pMN", "ESC/Eryth", "ESC/dp2")
names(new.cluster.ids) <- levels(mn.integrated)
mn.integrated <- RenameIdents(mn.integrated, new.cluster.ids)

mn.integrated <- subset(mn.integrated, cells = rownames(mn.integrated@meta.data[which(startsWith(mn.integrated@meta.data$orig.ident, "mn.dox")),]))
```

3) We further project the identified cell types onto the UMAP.
```{r, fig.width=8, fig.height=10}
DimPlot(mn.integrated, reduction = "umap", label = TRUE, pt.size = 0.5, split.by = "orig.ident", ncol = 2) + NoLegend() +
  scale_color_manual(values = c(RColorBrewer::brewer.pal(12, "Set3"), RColorBrewer::brewer.pal(12, "Paired")[1:6]))
```

#### Dorsal and MN Identities
Here we focus on the dorsal and motor neuron populations to assess for enrichment or depletion of these populations.

1) We first extract the embedding information and identify the dorsal populations (dl1 to dl5) and motor neuron population.
```{r}
mn.10x.subset.cell.embedding <- as.data.frame(mn.integrated@reductions$umap@cell.embeddings)

mn.10x.subset.cell.embedding$orig.ident <- mn.integrated@meta.data[rownames(mn.10x.subset.cell.embedding), "orig.ident"]
mn.10x.subset.cell.embedding$ident <- mn.integrated@active.ident[rownames(mn.10x.subset.cell.embedding)]
mn.10x.subset.cell.embedding$capy.call <- mn.integrated@meta.data[rownames(mn.10x.subset.cell.embedding), "capy.call"]
mn.10x.subset.cell.embedding$capy.call.general <- unlist(lapply(strsplit(mn.10x.subset.cell.embedding$capy.call, "_"), function(x) x[2]))
mn.10x.subset.cell.embedding[which(startsWith(mn.10x.subset.cell.embedding$capy.call, "ES")), "capy.call.general"] <- "ES"
mn.10x.subset.cell.embedding[which(startsWith(mn.10x.subset.cell.embedding$capy.call, "Multi")), "capy.call.general"] <- NA

mn.10x.subset.cell.embedding$orig.ident <- factor(mn.10x.subset.cell.embedding$orig.ident, 
                                                         levels = c("mn.dox", "mn.dox.sag", "mn.dox.ra", "mn.dox.ra.sag"),
                                                         ordered = T)
mn.10x.subset.cell.embedding.subset.dorsal <- mn.10x.subset.cell.embedding[which(mn.10x.subset.cell.embedding$capy.call.general %in% c("RP", "dl1", "dl2", "dl3", "dl4", "dl5")),]
mn.10x.subset.cell.embedding.subset.MN <- mn.10x.subset.cell.embedding[which(mn.10x.subset.cell.embedding$capy.call.general %in% c("MN")),]

mn.10x.subset.cell.embedding.subset.dorsal$replicate <- unlist(lapply(strsplit(rownames(mn.10x.subset.cell.embedding.subset.dorsal), "_"), function(x) x[2]))
```

2) Here we assess the density distribution of the dorsal cell types across different treaments, where we observe a significant decrease in the dorsal population upon addition of RA in particular.
```{r, fig.width=8, fig.height = 10}
ggplot(mn.10x.subset.cell.embedding, aes(x = UMAP_1, y = UMAP_2)) +
  geom_point(color = "lightgrey") +
  geom_point(data = mn.10x.subset.cell.embedding.subset.dorsal, aes(x = UMAP_1, y = UMAP_2), color= "black", fill = "black") +
  geom_density_2d(data = mn.10x.subset.cell.embedding.subset.dorsal, aes(color = after_stat(level))) +
  scale_color_gradient2(low = viridis(20, option = "A")[1], mid = viridis(20, option = "A")[10], high = viridis(20, option = "A")[20]) + 
  theme(legend.position="none",
        title = element_text(size = 14),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black")) +
  facet_wrap(.~orig.ident, ncol = 2)
```

3) Here we assess the density distribution of the motor neuron cell types across different treaments, where we observe significant increase in MN population upon addition of signaling molecules, particularly RA.
```{r, fig.width=8, fig.height = 10}
ggplot(mn.10x.subset.cell.embedding, aes(x = UMAP_1, y = UMAP_2)) +
  geom_point(color = "lightgrey") +
  #geom_density_2d_filled(data = mn.10x.subset.cell.embedding.subset.dorsal, alpha = 0.8, contour_var = "ndensity") +
  # scale_fill_manual(values = c("white", RColorBrewer::brewer.pal(9, "Oranges"))) +
  geom_point(data = mn.10x.subset.cell.embedding.subset.MN, aes(x = UMAP_1, y = UMAP_2), color= "black", fill = "black") +
  geom_density_2d(data = mn.10x.subset.cell.embedding.subset.MN, aes(color = after_stat(level))) +
  scale_color_gradient2(low = viridis(20, option = "A")[1], mid = viridis(20, option = "A")[10], high = viridis(20, option = "A")[20]) + 
  theme(legend.position="none",
        title = element_text(size = 14),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black")) +
  facet_wrap(.~orig.ident, ncol = 2)
```

#### Discrete Neuron Population
Here we assess the detailed breakdown of the neuronal populations within this classificaiton.
```{r}
mn.10x.subset.cell.embedding[which(is.na(mn.10x.subset.cell.embedding$capy.call.general)), "capy.call.general"] <- "Multi_ID"
mn.10x.subset.cell.embedding$replicate <- unlist(lapply(strsplit(rownames(mn.10x.subset.cell.embedding), "_"), function(x) x[2]))
single.id <- mn.10x.subset.cell.embedding[which(mn.10x.subset.cell.embedding$capy.call.general != "Multi_ID"), ]

single.id.R1 <- single.id[which(single.id$replicate == "R1"),]
single.id.R2 <- single.id[which(single.id$replicate == "R2"),]

cell.type.freq <- as.data.frame(apply(table(single.id$orig.ident, single.id$capy.call.general), 1, function(x) round(x*100/sum(x), digits = 3)))
progenitor.popu <- c("ES", "FP", "Neural.crest.neurons",  "dp1", "dp2","dp3", "dp4", "dp6", "p0","p1",
                     "p2", "p3", "pMN", "RP", "Mesoderm", "Myoblast", "Neural.Crest", "Skin", "Erythrocytes.II", "Erythropoeitic")
neuron.sp <- c("dl1", "dl2", "dl3", "dl4", "dl5", "V0", "V1", "V2a", "V2b", "MN", "V3")

cell.type.freq$ct <- rownames(cell.type.freq)
cell.type.freq.melt <- reshape2::melt(cell.type.freq)

cell.type.freq.melt$pn <- "Progenitors"
cell.type.freq.melt[which(cell.type.freq.melt$ct %in% neuron.sp), "pn"] <- "Neurons"

cell.type.freq.melt$ct <- factor(cell.type.freq.melt$ct, levels = rev(c("ES", "Erythrocytes.II", "Skin", "Neural.crest.neurons", "Mesoderm",
                                                                        "Myoblast", "Neural.Crest",  "Erythropoeitic",
                                                                        "FP", "dp1", "dp2","dp3", "dp4", "dp6", "p0","p1",
                                                                        "p2", "p3", "pMN", "RP", "dl1", "dl2", "dl3", "dl4", 
                                                                        "dl5", "V0", "V1", "V2a", "V2b", "MN", "V3")), ordered = T)
```

Plot the dot plot for the percentage representation of cell types across treatments.
```{r, fig.width=5, fig.height=7, warning=FALSE}
cell.type.freq.melt$variable <- factor(cell.type.freq.melt$variable, levels = c("mn.dox", "mn.dox.sag", "mn.dox.ra", "mn.dox.ra.sag"), ordered = T)
ggplot(cell.type.freq.melt[which(cell.type.freq.melt$pn == "Neurons"),], aes(x = variable, y = ct, size=ifelse(value==0, NA,  value))) +
  geom_point(aes(colour = variable, fill = variable)) +
  scale_size_area(name = "Percentage", max_size=12) +
  scale_color_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  guides(fill = FALSE, color = FALSE) +
  ggtitle("Direct Programming") +
  theme(legend.position = "bottom",
        axis.text = element_text(face = "bold.italic", size = 12),
        axis.ticks = element_blank(), 
        axis.title = element_blank(), 
        title = element_text(face = "bold.italic", size = 14),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1))
```

Overall, based on the discrete identities, we identify a significant increase in MN generation and decrease in dorsal neuron generation. Next, we turn our focus to hybrid cells.

#### Hybrid Cells
Here we process the binarization table and the qp scores for identification of significant hybrids.

1) Load binarization and classification data
```{r}
rep1 <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Binarization and Classification Outcomes/113020_MN_binarization_classification.Rds")
rep1.ra <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Binarization and Classification Outcomes/022421_MN_binarization_classification_no_hox_Rep1.Rds")
rep1.dox.ra <- rep1.ra$dox_ra
rep1.dox.ra.sag <- rep1.ra$dox_ra_sag
rep1.dox <- rep1$dox
rep1.dox.sag <- rep1$dox_sag

rep2 <- readRDS("~/Desktop/Reproducibility/Figure 5/Intermediates/Binarization and Classification Outcomes/012521_MN_binarization_classification_no_hox_Rep2.Rds")
rep2.dox.ra <- rep2$dox_ra
rep2.dox <- rep2$dox
rep2.dox.sag <- rep2$dox_sag
rep2.dox.ra.sag <- rep2$dox_ra_sag

list.bin.class.to.process <- list(rep1.dox, rep1.dox.sag, rep1.dox.ra, rep1.dox.ra.sag,
                                  rep2.dox, rep2.dox.sag, rep2.dox.ra, rep2.dox.ra.sag)
```

2) Load quadratic programming matrices
```{r}
dox.r1 <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 1/02_MN_Delile_Dox_scale.csv",
                   header = T, row.names = 1, stringsAsFactors = F)
dox.sag.r1 <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 1/02_MN_Delile_Dox_SAG_scale.csv",
                   header = T, row.names = 1, stringsAsFactors = F)
rep1.dox.ra.qp <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 1/03_MN_Delile_Dox_RA_no_hox_scale.csv",
                        header = T, row.names = 1, stringsAsFactors = F)
rep1.dox.ra.sag.qp <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 1/03_MN_Delile_Dox_RA_SAG_no_hox_scale.csv",
                        header = T, row.names = 1, stringsAsFactors = F)

dox.r2 <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 2/02_MN_Delile_Dox_scale.csv",
                   header = T, row.names = 1, stringsAsFactors = F)
dox.ra.r2 <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 2/02_MN_Delile_Dox_RA_scale.csv",
                   header = T, row.names = 1, stringsAsFactors = F)
dox.sag.r2 <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 2/02_MN_Delile_Dox_SAG_scale.csv",
                       header = T, row.names = 1, stringsAsFactors = F)
dox.ra.sag.r2 <- read.csv("~/Desktop/Reproducibility/Figure 5/Intermediates/QP Outcomes/Rep 2/02_MN_Delile_Dox_RA_SAG_scale.csv",
                          header = T, row.names = 1, stringsAsFactors = F)

list.qp.to.process <- list(dox.r1, dox.sag.r1, rep1.dox.ra.qp, rep1.dox.ra.sag.qp,
                           dox.r2, dox.sag.r2, dox.ra.r2, dox.ra.sag.r2)
```

3) Construct the data frame with the detailed breakdowns of the hybrid cells.
```{r}
labels <- c("Dox.R1", "Dox_SAG.R1", "Dox_RA.R1", "Dox_RA_SAG.R1",
            "Dox.R2", "Dox_SAG.R2", "Dox_RA.R2", "Dox_RA_SAG.R2")
prefixes <- c("mn.dox_R1", "mn.dox.sag_R1", "mn.dox.ra_R1", "mn.dox.ra.sag_R1",
              "mn.dox_R2", "mn.dox.sag_R2", "mn.dox.ra_R2", "mn.dox.ra.sag_R2")

all.multi <- data.frame()
cells.multi <- data.frame()

for (i in 1:length(list.bin.class.to.process)) {
  curr.set <- list.bin.class.to.process[[i]]
  curr.classification <- curr.set[[2]]
  curr.bin <- curr.set[[1]]
  curr.qp <- list.qp.to.process[[i]]
  
  multi.correct <- multi.id.curate.qp(curr.bin, curr.classification, curr.qp)
  multi.id.cells <- unique(multi.correct[[2]]$barcode[which(multi.correct[[2]]$call == "Multi_ID")])
  
  binary.m.id <- as.data.frame(curr.bin[multi.id.cells, ])
  binary.m.id$cell.id <- rownames(binary.m.id)
  binary.m.id.melt <- reshape2::melt(binary.m.id)
  binary.m.id.melt <- binary.m.id.melt[which(binary.m.id.melt$value > 0), ]
  
  binary.new.2 <- data.frame()
  binary.m.id.melt$variable <- as.character(binary.m.id.melt$variable)
  for (mc in multi.id.cells) {
    curr.sub <- binary.m.id.melt[which(binary.m.id.melt$cell.id == mc), ]
    curr.sub$variable <- gsub("9.5_", "", curr.sub$variable)
    curr.sub$variable <- gsub("10.5_", "", curr.sub$variable)
    curr.sub$variable <- gsub("11.5_", "", curr.sub$variable)
    curr.sub$variable <- gsub("12.5_", "", curr.sub$variable)
    curr.sub$variable <- gsub("13.5_", "", curr.sub$variable)
    curr.sub$variable <- gsub("_Nedd4_high", "", curr.sub$variable)
    curr.sub$variable <- gsub("_Actb_high", "", curr.sub$variable)
    
    if (length(unique(curr.sub$variable)) > 1) {
      curr.cell.type.combine <- paste0(gsub(pattern = "frxn_cell.type_", replacement = "", x = sort(unique(curr.sub$variable))), collapse = "-")
      
      curr.df <- data.frame(cell = mc, cell.type = curr.cell.type.combine, category = prefixes[i], stringsAsFactors = F)
      if (nrow(binary.new.2) <= 0){
        binary.new.2 <- curr.df
      } else {
        binary.new.2 <- rbind(binary.new.2, curr.df)
      }
    }
    
  }
  binary.new.2.stats <- table(binary.new.2$cell.type)
  binary.new.2.sub <- binary.new.2[which(binary.new.2$cell.type %in% names(binary.new.2.stats[which(binary.new.2.stats >= 10)])),]
  new.rslt <- as.data.frame(table(binary.new.2.sub$cell.type) * 100/sum(table(binary.new.2.sub$cell.type)))
  new.rslt$category <- labels[i]
  
  if (nrow(all.multi) <= 0) {
    all.multi <- new.rslt
  } else {
    all.multi <- rbind(all.multi, new.rslt)
  }

  if (nrow(cells.multi) <= 0) {
    cells.multi <- binary.new.2.sub
  } else {
    cells.multi <- rbind(cells.multi, binary.new.2.sub)
  }
}

cells.multi.r1 <- cells.multi[which(endsWith(cells.multi$category, "R1")),]
cells.multi.r2 <- cells.multi[which(endsWith(cells.multi$category, "R2")),]

cells.multi.r1$treatcall <- gsub(".R1", "", cells.multi.r1$category)
cells.multi.r2$treatcall <- gsub(".R2", "", cells.multi.r2$category)
```

4) Particularly, we look at the distribution of three major hybrids, including ES-MN, ES-dl3, and dl3-MN.
```{r}
all.multi$general.cat <- unlist(lapply(strsplit(all.multi$category, "[.]"), function(x) x[[1]]))
all.multi <- setDT(all.multi)
all.multi.mtx <- dcast(all.multi, Var1~general.cat, fun.aggregate = sum, value.var = "Freq")
all.multi.mtx.2 <- dcast(all.multi, Var1~category, fun.aggregate = sum, value.var = "Freq")
all.multi.mtx[,2] <- all.multi.mtx[,2] * 100/sum(all.multi.mtx[,2])
all.multi.mtx[,3] <- all.multi.mtx[,3] * 100/sum(all.multi.mtx[,3])
all.multi.mtx[,4] <- all.multi.mtx[,4] * 100/sum(all.multi.mtx[,4])
all.multi.mtx[,5] <- all.multi.mtx[,5] * 100/sum(all.multi.mtx[,5])
all.multi.mtx <- as.data.frame(all.multi.mtx)
all.multi.mtx.sort <- all.multi.mtx[order(-all.multi.mtx$Dox),]
all.multi.mtx.sort$Var1 <- factor(all.multi.mtx.sort$Var1,
                                  levels = all.multi.mtx.sort$Var1,
                                  ordered = T)
all.multi.mtx.melt <- reshape2::melt(all.multi.mtx.sort)
```

```{r, fig.width=5.5, fig.height=7}
all.multi.mtx.melt.sub <- all.multi.mtx.melt[which(all.multi.mtx.melt$Var1 %in% c("dl3-ES", "dl3-MN", "ES-MN")), ]
all.multi.mtx.melt.sub$Var1 <- factor(as.character(all.multi.mtx.melt.sub$Var1), levels = c("ES-MN", "dl3-ES", "dl3-MN"), ordered = T)
all.multi.mtx.melt.sub$variable <- factor(as.character(all.multi.mtx.melt.sub$variable),
                                          levels = c("Dox", "Dox_SAG", "Dox_RA", "Dox_RA_SAG"),
                                          ordered = T)

all.multi.mtx.melt.sub$sd <- c(0.495, 0.17, 2.5065,
                               2.6065, 5.87, 7.69,
                               0.6533, 1.95, 5.39,
                               1.2845, 0.325, 4.66)/sqrt(2)

ggplot(all.multi.mtx.melt.sub, aes(x = Var1, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin=value-sd, ymax=value+sd), width=.2,
                position=position_dodge(.9)) +
  scale_fill_viridis_d(option = "A", begin = 0.15, end = 0.85) +
  theme(legend.position = "right",
        axis.text = element_text(face = "bold", size = 12),
        axis.title.x = element_text(face = "bold.italic", size = 14),
        axis.title.y = element_text(face = "bold.italic", size = 14),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        title = element_text(face = "bold.italic", size = 14),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_blank())
```

#### Coexpression patterns
Here we assess coexpression of dorsal markers vs. motor neuron markers.

1) We extract the normalized data from the seurat object for several candidate genes.
```{r}
gene.table <- as.data.frame(t(mn.integrated@assays$RNA@data[c("Lhx2", "Mnx1", "Ascl1", "Neurog2", "Lhx5", "Lhx9", "Pou4f1", "Isl1", "Lhx3", "Vsx2", "Gata3"), ]))

seurat.obj.meta <- mn.integrated@meta.data
seurat.obj.meta <- cbind(seurat.obj.meta, gene.table[rownames(seurat.obj.meta),])
seurat.obj.meta <- cbind(seurat.obj.meta, mn.10x.subset.cell.embedding[,c(1,2,4,6)])
```

2) We look at the co-expression pattern of Pou4f1 (dorsal) vs Mnx1 (motor neuron) across different treatments.
```{r, fig.width=8, fig.height=9}
dl3.mn.hybrid <- paste0(cells.multi$category[which(cells.multi$cell.type == "dl3-MN")], "_", cells.multi$cell[which(cells.multi$cell.type == "dl3-MN")])
dorsal.mn.table <- seurat.obj.meta[which(seurat.obj.meta$capy.call.general %in% c("dl1", "dl2","dl3", "dl4","dl5", "MN")),]
dorsal.mn.table$new.general.call <- dorsal.mn.table$capy.call.general
dorsal.mn.table$new.general.call[which(dorsal.mn.table$new.general.call %in% c("dl1", "dl2","dl3", "dl4","dl5"))] <- "Dorsal"


seurat.meta.hybrid.dl3.mn <- seurat.obj.meta[c(dl3.mn.hybrid, rownames(dorsal.mn.table)), ]
seurat.meta.hybrid.dl3.mn[dl3.mn.hybrid, "capy.call.general"] <- "dl3-MN"

seurat.meta.hybrid.dl3.mn$dorsal.mixed.mn <- seurat.meta.hybrid.dl3.mn$capy.call.general
seurat.meta.hybrid.dl3.mn$dorsal.mixed.mn[which(seurat.meta.hybrid.dl3.mn$dorsal.mixed.mn %in% c("dl1", "dl2", "dl3", "dl4", "dl5"))] <- "Dorsal"

ggplot(seurat.meta.hybrid.dl3.mn[which(startsWith(as.character(seurat.meta.hybrid.dl3.mn$orig.ident),"mn.dox")),], aes(x = Mnx1, y = Pou4f1, color = dorsal.mixed.mn)) +
  geom_point() +
  scale_color_brewer(palette = "Set1") +
  facet_wrap(.~orig.ident) +
  theme(legend.position="bottom",
        title = element_text(size = 14),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_line(color = "lightgrey"),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 90))

```

3) We further quantify the percentage of co-expression across different treatments, where we identify significant decrease in co-expressed cells upon addition of RA or SAG or RA + SAG. The level decreases to more similar level of the in vivo (delile et al 2019) dataset.
```{r}
seurat.meta.hybrid.dl3.mn$coexpressed <- 0
seurat.meta.hybrid.dl3.mn$coexpressed[which(seurat.meta.hybrid.dl3.mn$Mnx1 > 0 & seurat.meta.hybrid.dl3.mn$Pou4f1 > 0)] <- 1

seurat.meta.hybrid.dl3.mn$orig.ident <- as.character(seurat.meta.hybrid.dl3.mn$orig.ident)
rslt.2 <- table(seurat.meta.hybrid.dl3.mn$orig.ident, seurat.meta.hybrid.dl3.mn$coexpressed)
rslt.2 <- as.data.frame(apply(rslt.2, 1, function(x) x/sum(x)))

rslt.2$coexpression.label <- c("Not-Expressed", "Co-Expressed")
rslt.melt <- reshape2::melt(rslt.2)
new.row.to.add <- data.frame(coexpression.label = c("Not-Expressed", "Co-Expressed"), variable = rep("In Vivo", 2), value = c(0.4977, 0.0095785))
rslt.melt <- rbind(rslt.melt, new.row.to.add)

rslt.melt$variable <- factor(rslt.melt$variable, levels = c("mn.dox", "mn.dox.sag", "mn.dox.ra", "mn.dox.ra.sag", "In Vivo"))

ggplot(rslt.melt[which(rslt.melt$coexpression.label == "Co-Expressed"), ], aes(x = variable, y = value *100, fill = coexpression.label)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_brewer(palette = "Paired") +
  labs(x = "", y = "Percentage Composition") +
  theme(legend.position="bottom",
        title = element_text(size = 14),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_line(color = "lightgrey"),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"))
```



